From 9b225fac81186176075f673dfe5cf8e373b2068a Mon Sep 17 00:00:00 2001
From: Dan Horak <dan@danny.cz>
Date: Sun, 20 Jul 2008 09:24:05 +0200
Subject: [PATCH 01/12] s390-tools-1.5.3-zipl-zfcpdump-2

---
 common.mak | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/common.mak b/common.mak
index 44adc6e..4373da5 100644
--- a/common.mak
+++ b/common.mak
@@ -62,8 +62,8 @@ GROUP		= $(shell id -gn)
 export INSTROOT BINDIR LIBDIR MANDIR OWNER GROUP
 
 # Special defines for zfcpdump
-ZFCPDUMP_DIR    = /usr/local/share/zfcpdump
-ZFCPDUMP_IMAGE  = zfcpdump.image
+ZFCPDUMP_DIR    = /boot
+ZFCPDUMP_IMAGE  = zfcpdump
 ZFCPDUMP_RD     = zfcpdump.rd
 export ZFCPDUMP_DIR ZFCPDUMP_IMAGE ZFCPDUMP_RD
 
-- 
1.8.5.3


From a3d9221076f9eb7cc8434baac71327f786351c63 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Dan=20Hor=C3=A1k?= <dan@danny.cz>
Date: Thu, 23 Apr 2009 11:46:01 +0200
Subject: [PATCH 02/12] s390-tools-1.8.1-fdasd-su

---
 fdasd/fdasd.c | 10 ++++++----
 1 file changed, 6 insertions(+), 4 deletions(-)

diff --git a/fdasd/fdasd.c b/fdasd/fdasd.c
index ba22475..f2ac417 100644
--- a/fdasd/fdasd.c
+++ b/fdasd/fdasd.c
@@ -2229,10 +2229,12 @@ static void fdasd_get_geometry (fdasd_anchor_t *anc)
 		if (anc->verbose) printf("disk type check     : ok\n");
 
 		if (dasd_info.FBA_layout != 0) {
-			snprintf(err_str, ERROR_STRING_SIZE,
-				 "%s is not formatted with z/OS compatible "
-				 "disk layout!", options.device);
-			fdasd_error(anc, wrong_disk_format, err_str);
+			if (!anc->silent) {
+				snprintf(err_str, ERROR_STRING_SIZE,
+					"%s is not formatted with z/OS compatible "
+					"disk layout!", options.device);
+				fdasd_error(anc, wrong_disk_format, err_str);
+			}
 		}
 
 		if (anc->verbose) printf("disk layout check   : ok\n");
-- 
1.8.5.3


From d13c754f68ea838a47b8125006b9b493cfbbb7f4 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Dan=20Hor=C3=A1k?= <dan@danny.cz>
Date: Wed, 21 Aug 2013 12:13:30 +0200
Subject: [PATCH 03/12] dbginfo.sh: Avoiding exclusion list for pipes in sysfs

Description:  dbginfo.sh: Avoiding exclusion list for pipes in sysfs
Symptom:      The dbginfo.sh script hangs
Problem:      The trace pipes for CPU tracing in sysfs can potentially block
              dbginfo.
Solution:     Switch over to make use of dd with the nonblock option to savely
              collect the whole sysfs without keeping an exclusion list up to
              date
Reproduction: Run dbginfo on a kernel that provides trace_pipe and
              trace_pipe_raw
---
 scripts/dbginfo.sh | 15 ++++++---------
 1 file changed, 6 insertions(+), 9 deletions(-)

diff --git a/scripts/dbginfo.sh b/scripts/dbginfo.sh
index 6d07132..0ada40b 100755
--- a/scripts/dbginfo.sh
+++ b/scripts/dbginfo.sh
@@ -181,8 +181,8 @@ fi
 if test ${LINUX_SUPPORT_SYSFSDBF} -eq 1; then
     if test -e /proc/s390dbf; then
 	PROCFILES="${PROCFILES}\
-          `find /proc/s390dbf -type f -not -path \"*/raw\" -not -path \"*/flush\" 2>/dev/null`\
-          "
+	  `find /proc/s390dbf -type f -not -path \"*/raw\" -not -path \"*/flush\" 2>/dev/null`\
+	  "
     fi
 fi
 
@@ -492,12 +492,9 @@ collect_sysfs() {
 	    mkdir -p "${WORKPATH}${dir_name}"
 	done
 
-	find /sys -noleaf -type f -perm /444 \
-	    -a -not -name "*trace_pipe" \
-	    -a -not -path "*debug/hid*/events" \
-	    -a -not -path "*debug/usb/usbmon/*" 2>/dev/null | while IFS= read -r file_name; do
+	find /sys -noleaf -type f -perm /444 2>/dev/null | while IFS= read -r file_name; do
 	    echo "  ${file_name}"
-	    cp -P --preserve=links -L --parents "${file_name}" "${WORKPATH}"
+	    dd if="${file_name}" iflag=nonblock of="${WORKPATH}${file_name}"
 	done
 
 	if test ${debugfs_mounted} -eq 1; then
@@ -574,7 +571,7 @@ call_run_command() {
 
     # check if command exists
     if ! which "${raw_cmd}" >/dev/null 2>&1; then
-        # check if command is a builtin
+	# check if command is a builtin
 	if ! command -v "${raw_cmd}" >/dev/null 2>&1; then
 	    echo "  WARNING: Command \"${raw_cmd}\" not available" >> "${logfile}"
 	    echo >> "${logfile}"
@@ -722,7 +719,7 @@ environment_setup()
 
     if test -e "${WORKDIR_BASE}${SCRIPTNAME}".lock; then
 	print_alreadyrunning
-        exit 1
+	exit 1
     else
 	touch "${WORKDIR_BASE}${SCRIPTNAME}".lock
     fi
-- 
1.8.5.3


From 7d540e7f40c731092ac655d1d38af7d69ceee706 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Dan=20Hor=C3=A1k?= <dan@danny.cz>
Date: Wed, 21 Aug 2013 12:13:58 +0200
Subject: [PATCH 04/12] zipl: Fix zipl "--force" option for DASD multi-volume
 dump

Description:  zipl: Fix zipl "--force" option for DASD multi-volume dump
Symptom:      When specifying "--force" and afterwards the dump partition is
              modified, for example by creating a swap partition, the dump
              still fails with the message "Wrong signature".
Problem:      The "larl" instruction was used to load an odd address which
              results in an incorrect even address.
Solution:     Load the correct even address.
Reproduction: 1) Create ECKD MV dump DASDs:
                 $ zipl -M mvdump.list --force
              2) Modify partitions:
                 $ dd if=/dev/zero of=/dev/dasdx1
              3) Create dump
                 -> Should work with this fix
---
 zipl/boot/eckd2mvdump.S | 5 +++--
 1 file changed, 3 insertions(+), 2 deletions(-)

diff --git a/zipl/boot/eckd2mvdump.S b/zipl/boot/eckd2mvdump.S
index f1cec78..529d6b3 100644
--- a/zipl/boot/eckd2mvdump.S
+++ b/zipl/boot/eckd2mvdump.S
@@ -153,7 +153,7 @@ _dump_mem_64:
 
 .Lcheck_sign:
 	larl    %r7,.Lforce
-	tm      0(%r7),0x01                   # was zipl --force specified?
+	tm      1(%r7),0x01                   # was zipl --force specified?
 	bo      .Lheaders-0b(%r13)            # yes, skip signature check
 	llgf    %r2,.Ldev_start_blk-0b(%r13)  # start block of partition
 	lghi    %r3,TMP_PAGE_START            # destination of read operation
@@ -576,8 +576,9 @@ _ioblock_64:
 	.byte 0x85, 0x40, 0xa2, 0xa3, 0x81, 0x94, 0x97, 0xa2
 	.byte 0x00
 
-.org (MVDUMP_TOOL_SIZE - 9)
+.org (MVDUMP_TOOL_SIZE - 10)
 .Lforce:
+	.byte 0x00
 	.byte 0x00                            # is set to 0x01 by zipl -f
 .Lmem_upper_limit:
 	.long 0xffffffff,0xffffffff           # can be used for memsize=xxx
-- 
1.8.5.3


From 21caf0d0dc05c5e950f369f72027a203a7d3e772 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Dan=20Hor=C3=A1k?= <dan@danny.cz>
Date: Tue, 5 Nov 2013 12:23:18 +0100
Subject: [PATCH 05/12] zipl: Use "possible_cpus" kernel parameter

Description:  zipl: Use "possible_cpus" kernel parameter
Symptom:      The zfcpdump system might run out-of memory.
Problem:      For each possible CPU the zfcpdump kernel consumes memory for
              the per-CPU data structures. Since it only runs with one CPU
              this is not necessary. Because only 32 MiB are available for
              zfcpdump the per-CPU data should not be allocated.
Solution:     Use the kernel parameter "possible_cpus=1".
Reproduction: To verify that the fix is included check that the zipl -D output
              line "kernel parmline" contains "possible_cpus=1".
---
 zipl/src/bootmap.c | 5 +++--
 1 file changed, 3 insertions(+), 2 deletions(-)

diff --git a/zipl/src/bootmap.c b/zipl/src/bootmap.c
index cc2ed16..68dffe1 100644
--- a/zipl/src/bootmap.c
+++ b/zipl/src/bootmap.c
@@ -603,10 +603,11 @@ create_dump_fs_parmline(const char* parmline, const char* root_dev,
 	if (!result)
 		return NULL;
 	snprintf(result, DUMP_PARAM_MAX_LEN, "%s%sroot=%s dump_part=%d "
-		 "dump_mem=%lld maxcpus=%d cgroup_disable=memory",
+		 "dump_mem=%lld maxcpus=%d possible_cpus=%d "
+		 "cgroup_disable=memory",
 		 parmline ? parmline : "",
 		 parmline ? " " : "", root_dev, part_num,
-		 (unsigned long long) mem, max_cpus);
+		 (unsigned long long) mem, max_cpus, max_cpus);
 	result[DUMP_PARAM_MAX_LEN - 1] = 0;
 	return result;
 }
-- 
1.8.5.3


From d3792e20601152ac2deea8d592b9fc176590ec5f Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Dan=20Hor=C3=A1k?= <dan@danny.cz>
Date: Tue, 19 Nov 2013 18:02:03 +0100
Subject: [PATCH 06/12] dbginfo.sh: enhancements for script execution and man
 page

Description:  dbginfo.sh: enhancements for script execution and man page
Symptom:      The result of the data collection does not provide all required
              information which is required to finally analyze the situation.
Problem:      The execution of the script has the following issues
              * The script does not verify if it is running for user root
              * The script does not post any messages into syslog during
                runtime. This makes it quite difficulty to verify, when the
                data collection started and ended.
              * The script does not run in a dedicated locale. The output of
                various tools can include messages in the language which has
                been set by the administrator.
              * Some Linux on System z specific tools are not yet processed
                during data collection, such as lsmem and lschp.
              * Some important configuration files are still not collected,
                such as openssl.conf and openssl.cnf.
              * Some parts in the man page might not be shown properly
Solution:     The following changes are implemented:
              * Added verification if the script is executed for user root
              * Added logging mechanism to print messages into syslog.
              * Added statement for LC_ALL to set the "C" 'standard' locale
              * Added lsmem and lschp for commands being executed
              * Added openssl.conf and openssl.cnf to be collected as
                configuration files
              * Corrected some parts in the man page
Reproduction: Some information how to reproduce the issues
              * Run the script as 'non-root' user. The output will not contain
                all the important information.
              * Run the script and verify if something is stated in syslog,
                when the script is executed.
              * Run the script on a system, where the locale is set to
                'non-en' locale. Some out put of important commands will be
                printed in the non-en locale.
              * Run the data collection and verify that the output of lsmem,
                and lschp and that the config files openssl.conf, and
                openssl.cnf are not collected.
---
 scripts/dbginfo.sh   | 167 ++++++++++++++++++++++++++++++---------------------
 scripts/dbginfo.sh.1 |  34 +++++------
 2 files changed, 116 insertions(+), 85 deletions(-)

diff --git a/scripts/dbginfo.sh b/scripts/dbginfo.sh
index 0ada40b..9b64076 100755
--- a/scripts/dbginfo.sh
+++ b/scripts/dbginfo.sh
@@ -28,6 +28,9 @@
 # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 ###############################################################################
 
+# Switching to neutral locale
+export LC_ALL=C
+
 # The kernel release version as delivered from uname -r
 readonly KERNEL_RELEASE_VERSION="`uname -r 2>/dev/null`"
 
@@ -44,6 +47,9 @@ readonly TERMINAL="`tty 2>/dev/null`"
 # The processor ID for the first processor
 readonly PROCESSORID=`grep -E ".*processor 0:.*" /proc/cpuinfo | sed 's/.*identification[[:space:]]*\=[[:space:]]*\([[:alnum:]]*\).*/\1/g'`
 
+# The processor version for the first processor
+readonly PROCESSORVERSION=`grep -E ".*processor 0:.*" /proc/cpuinfo | sed 's/.*version[[:space:]]*\=[[:space:]]*\([[:alnum:]]*\).*/\1/g'`
+
 # The current date
 readonly DATETIME=`date +%Y-%m-%d-%H-%M-%S 2>/dev/null`
 
@@ -114,13 +120,13 @@ else
     readonly LINUX_SUPPORT_SYSFSDBF=0
 fi
 
-# Is this Linux on System z under z/VM (0=yes, 1=no)
-if grep -q 'z/VM' /proc/sysinfo 2>/dev/null; then
-    readonly LINUX_ON_ZVM=0
+if test "x${PROCESSORVERSION}" = "xFF" || test "x${PROCESSORVERSION}" = "xff"; then
+    readonly RUNTIME_ENVIRONMENT=`grep -E "VM00.*Control Program.*" /proc/sysinfo| sed 's/.*:[[:space:]]*\([[:graph:]]*\).*/\1/g'`;
 else
-    readonly LINUX_ON_ZVM=1
+    readonly RUNTIME_ENVIRONMENT="LPAR"
 fi
 
+
 ########################################
 
 # Collection of proc fs entries
@@ -181,8 +187,8 @@ fi
 if test ${LINUX_SUPPORT_SYSFSDBF} -eq 1; then
     if test -e /proc/s390dbf; then
 	PROCFILES="${PROCFILES}\
-	  `find /proc/s390dbf -type f -not -path \"*/raw\" -not -path \"*/flush\" 2>/dev/null`\
-	  "
+          `find /proc/s390dbf -type f -not -path \"*/raw\" -not -path \"*/flush\" 2>/dev/null`\
+          "
     fi
 fi
 
@@ -277,7 +283,9 @@ CMDS="uname -a\
   :multipath -d\
   :multipath -t\
   :lsqeth\
+  :lschp\
   :lscss\
+  :lsmem\
   :lsdasd\
   :ziorep_config -ADM\
   :lsmod\
@@ -376,7 +384,7 @@ collect_cmdsout() {
     local cmd
     local ifs_orig="${IFS}"
 
-    pr_log_stdout " 1 of ${COLLECTION_COUNT}: Collecting command output"
+    pr_syslog_stdout "1 of ${COLLECTION_COUNT}: Collecting command output"
 
     IFS=:
     for cmd in ${CMDS}; do
@@ -397,8 +405,8 @@ collect_vmcmdsout() {
     local module_loaded=1
     local ifs_orig="${IFS}"
 
-    if test ${LINUX_ON_ZVM} -eq 0; then
-	pr_log_stdout " 2 of ${COLLECTION_COUNT}: Collecting z/VM command output"
+    if echo "${RUNTIME_ENVIRONMENT}" | grep -qi "z/VM" >/dev/null 2>&1; then
+	pr_syslog_stdout "2 of ${COLLECTION_COUNT}: Collecting z/VM command output"
 
 	if type vmcp >/dev/null 2>&1; then
 	    cp_command="vmcp"
@@ -412,8 +420,8 @@ collect_vmcmdsout() {
 	    fi
 	else
 	    pr_log_stdout " "
-	    pr_log_stdout "  WARNING: No program found to communicate to z/VM CP"
-	    pr_log_stdout "  WARNING: Skipping the collection of z/VM command output"
+	    pr_log_stdout "WARNING: No program found to communicate to z/VM CP"
+	    pr_log_stdout "WARNING: Skipping the collection of z/VM command output"
 	    pr_log_stdout " "
 	    return 1
 	fi
@@ -443,7 +451,7 @@ collect_vmcmdsout() {
 	    rmmod vmcp
 	fi
     else
-	pr_log_stdout " 2 of ${COLLECTION_COUNT}: Running in LPAR, no z/VM command output collected"
+	pr_syslog_stdout "2 of ${COLLECTION_COUNT}: Collecting z/VM command output skipped - no z/VM environment"
     fi
 
     pr_log_stdout " "
@@ -454,7 +462,7 @@ collect_vmcmdsout() {
 collect_procfs() {
     local file_name
 
-    pr_log_stdout " 3 of ${COLLECTION_COUNT}: Collecting procfs"
+    pr_syslog_stdout "3 of ${COLLECTION_COUNT}: Collecting procfs"
 
     for file_name in ${PROCFILES}; do
 	call_collect_file "${file_name}"
@@ -473,7 +481,7 @@ collect_sysfs() {
 
     # Requires kernel version newer then 2.4
     if test ${LINUX_SUPPORT_SYSFS} -eq 0; then
-	pr_log_stdout " 4 of ${COLLECTION_COUNT}: Collecting sysfs"
+	pr_syslog_stdout "4 of ${COLLECTION_COUNT}: Collecting sysfs"
 	# Requires kernel version of 2.6.13 or newer
 	if test ${LINUX_SUPPORT_SYSFSDBF} -eq 0; then
 	    if ! grep -qE "${MOUNT_POINT_DEBUGFS}.*debugfs" /proc/mounts 2>/dev/null; then
@@ -481,7 +489,7 @@ collect_sysfs() {
 		    sleep 2
 		    debugfs_mounted=1;
 		else
-		    pr_log_stdout "  WARNING: \"Unable to mount debugfs ${MOUNT_POINT_DEBUGFS}\""
+		    pr_log_stdout "WARNING: \"Unable to mount debugfs ${MOUNT_POINT_DEBUGFS}\""
 		fi
 	    fi
 	fi
@@ -493,7 +501,7 @@ collect_sysfs() {
 	done
 
 	find /sys -noleaf -type f -perm /444 2>/dev/null | while IFS= read -r file_name; do
-	    echo "  ${file_name}"
+	    echo " ${file_name}"
 	    dd if="${file_name}" iflag=nonblock of="${WORKPATH}${file_name}"
 	done
 
@@ -501,7 +509,7 @@ collect_sysfs() {
 	    umount "${MOUNT_POINT_DEBUGFS}"
 	fi
     else
-	pr_log_stdout " 4 of ${COLLECTION_COUNT}: Collecting sysfs skipped. Kernel `uname -r` must be newer than 2.4"
+	pr_syslog_stdout "4 of ${COLLECTION_COUNT}: Collecting sysfs skipped. Kernel `uname -r` must be newer than 2.4"
     fi
 
     pr_log_stdout " "
@@ -512,7 +520,7 @@ collect_sysfs() {
 collect_logfiles() {
     local file_name
 
-    pr_log_stdout " 5 of ${COLLECTION_COUNT}: Collecting log files"
+    pr_syslog_stdout "5 of ${COLLECTION_COUNT}: Collecting log files"
 
     for file_name in ${LOGFILES}; do
 	call_collect_file "${file_name}"
@@ -521,11 +529,12 @@ collect_logfiles() {
     pr_log_stdout " "
 }
 
+
 ########################################
 collect_configfiles() {
     local file_name
 
-    pr_log_stdout " 6 of ${COLLECTION_COUNT}: Collecting config files"
+    pr_syslog_stdout "6 of ${COLLECTION_COUNT}: Collecting config files"
 
     for file_name in ${CONFIGFILES}; do
 	call_collect_file "${file_name}"
@@ -542,16 +551,16 @@ collect_osaoat() {
 
     if which qethqoat >/dev/null 2>&1; then
 	if test -n "${network_devices}"; then
-	    pr_log_stdout " 7 of ${COLLECTION_COUNT}: Collecting osa oat output"
+	    pr_syslog_stdout "7 of ${COLLECTION_COUNT}: Collecting osa oat output"
 	    for network_device in "${network_devices}"; do
 		call_run_command "qethqoat ${network_device}" "${OUTPUT_FILE_OSAOAT}.out" &&
 		call_run_command "qethqoat -r ${network_device}" "${OUTPUT_FILE_OSAOAT}_${network_device}.raw"
 	    done
 	else
-	    pr_log_stdout " 7 of ${COLLECTION_COUNT}: Collecting osa oat output skipped - no devices"
+	    pr_syslog_stdout "7 of ${COLLECTION_COUNT}: Collecting osa oat output skipped - no devices"
 	fi
     else
-	pr_log_stdout " 7 of ${COLLECTION_COUNT}: Collecting osa oat output skipped - not available"
+	pr_syslog_stdout "7 of ${COLLECTION_COUNT}: Collecting osa oat output skipped - not available"
     fi
 
     pr_log_stdout " "
@@ -571,16 +580,16 @@ call_run_command() {
 
     # check if command exists
     if ! which "${raw_cmd}" >/dev/null 2>&1; then
-	# check if command is a builtin
+        # check if command is a builtin
 	if ! command -v "${raw_cmd}" >/dev/null 2>&1; then
-	    echo "  WARNING: Command \"${raw_cmd}\" not available" >> "${logfile}"
+	    echo "WARNING: Command \"${raw_cmd}\" not available" >> "${logfile}"
 	    echo >> "${logfile}"
 	    return 1;
 	fi
     fi
 
     if ! eval "${cmd}" >> "${logfile}" 2>&1; then
-	echo "  WARNING: Command \"${cmd}\" failed" >> "${logfile}"
+	echo "WARNING: Command \"${cmd}\" failed" >> "${logfile}"
 	echo >> "${logfile}"
 	return 1
     else
@@ -595,7 +604,7 @@ call_collect_file() {
     local directory_name
     local file_name="${1}"
 
-    echo "  ${file_name}"
+    echo " ${file_name}"
 
     directory_name="`dirname \"${file_name}\" 2>/dev/null`"
     if test ! -e "${WORKPATH}${directory_name}"; then
@@ -616,8 +625,8 @@ call_collect_file() {
 # print version info
 print_version() {
     cat <<EOF
- ${SCRIPTNAME}: Debug information script version %S390_TOOLS_VERSION%
- Copyright IBM Corp. 2002, 2013
+${SCRIPTNAME}: Debug information script version %S390_TOOLS_VERSION%
+Copyright IBM Corp. 2002, 2013
 EOF
 }
 
@@ -631,30 +640,30 @@ print_usage()
     cat <<EOF
 
 
- Usage: ${SCRIPTNAME} [OPTIONS]
+Usage: ${SCRIPTNAME} [OPTIONS]
 
- This script collects runtime, configuration and trace information about
- your Linux on System z installation for debugging purposes.
+This script collects runtime, configuration and trace information about
+your Linux on System z installation for debugging purposes.
 
- It also traces information about z/VM if the Linux runs under z/VM.
+It also traces information about z/VM if the Linux runs under z/VM.
 
 
- The collected information is written to a TAR archive named
+The collected information is written to a TAR archive named
 
-     /tmp/DBGINFO-[date]-[time]-[hostname]-[processorid].tgz
+    /tmp/DBGINFO-[date]-[time]-[hostname]-[processorid].tgz
 
- where [date] and [time] are the date and time when debug data is collected.
- [hostname] indicates the hostname of the system the data was collected from.
- The [processorid] is taken from the processor 0 and indicates the processor
- identification.
+where [date] and [time] are the date and time when debug data is collected.
+[hostname] indicates the hostname of the system the data was collected from.
+The [processorid] is taken from the processor 0 and indicates the processor
+identification.
 
- Options:
+Options:
 
         -h|--help          print this help
         -v|--version       print version information
 
 
- Please report bugs to: linux390@de.ibm.com
+Please report bugs to: linux390@de.ibm.com
 
 EOF
 }
@@ -668,9 +677,9 @@ print_alreadyrunning() {
     cat <<EOF
 
 
- Please check the system if another instance of ${SCRIPTNAME} is already
- running. If this is not the case, please remove the lock file
- '${WORKDIR_BASE}${SCRIPTNAME}.lock'.
+Please check the system if another instance of ${SCRIPTNAME} is already
+running. If this is not the case, please remove the lock file
+'${WORKDIR_BASE}${SCRIPTNAME}.lock'.
 EOF
 }
 
@@ -689,15 +698,15 @@ commandline_parse()
 	    print_version
 	else
 	    echo
-	    echo " ${SCRIPTNAME}: invalid option ${cmdline_arg1}"
-	    echo " Try '${SCRIPTNAME} --help' for more information"
+	    echo "${SCRIPTNAME}: invalid option ${cmdline_arg1}"
+	    echo "Try '${SCRIPTNAME} --help' for more information"
 	    echo
 	    exit 1
 	fi
 	exit 0
     elif test ${cmdline_count} -ge 1; then
 	echo
-	echo " ERROR: Invalid number of arguments!"
+	echo "ERROR: Invalid number of arguments!"
 	echo
 	print_usage
 	exit 1
@@ -712,21 +721,21 @@ environment_setup()
     if test ! -e "${WORKDIR_BASE}"; then
 	mkdir -p "${WORKDIR_BASE}"
     elif test ! -d "${WORKDIR_BASE}"; then
-	echo " ERROR: ${WORKDIR_BASE} exists but this is a file!"
-	echo "        Please make sure ${WORKDIR_BASE} is a directory."
+	echo "ERROR: ${WORKDIR_BASE} exists but this is a file!"
+	echo "       Please make sure ${WORKDIR_BASE} is a directory."
 	exit 1
     fi
 
     if test -e "${WORKDIR_BASE}${SCRIPTNAME}".lock; then
 	print_alreadyrunning
-	exit 1
+        exit 1
     else
 	touch "${WORKDIR_BASE}${SCRIPTNAME}".lock
     fi
 
     if ! mkdir "${WORKPATH}" 2>/dev/null; then
-	echo " ERROR: Target directory ${WORKPATH} already exists or"
-	echo "        ${WORKDIR_BASE} does not exist!"
+	echo "ERROR: Target directory ${WORKPATH} already exists or"
+	echo "       ${WORKDIR_BASE} does not exist!"
 	exit 1
     fi
 }
@@ -736,18 +745,18 @@ environment_setup()
 # create gzip-ped tar file
 create_package()
 {
-    pr_stdout " Finalizing: Creating archive with collected data"
+    pr_stdout "Finalizing: Creating archive with collected data"
     cd "${WORKDIR_BASE}"
 
     if ! tar -czf "${WORKARCHIVE}" "${WORKDIR_CURRENT}"; then
 	pr_stdout " "
-	pr_stdout " ERROR: Collection of data failed!"
-	pr_stdout "        The creation of ${WORKARCHIVE} was not successful."
-	pr_stdout "        Please check the directory ${WORKDIR_BASE}"
-	pr_stdout "        to provide enough free available space."
+	pr_stdout "ERROR: Collection of data failed!"
+	pr_stdout "       The creation of ${WORKARCHIVE} was not successful."
+	pr_stdout "       Please check the directory ${WORKDIR_BASE}"
+	pr_stdout "       to provide enough free available space."
     else
 	pr_stdout " "
-	pr_stdout " Collected data was saved to:"
+	pr_stdout "Collected data was saved to:"
 	pr_stdout " >>  ${WORKARCHIVE}  <<"
     fi
 
@@ -761,14 +770,14 @@ environment_cleanup()
 {
     if ! rm -rf "${WORKPATH}" 2>/dev/null; then
 	pr_stdout " "
-	pr_stdout " WARNING: Deletion of ${WORKPATH} failed"
-	pr_stdout " Please remove the directory manually"
+	pr_stdout "WARNING: Deletion of ${WORKPATH} failed"
+	pr_stdout "Please remove the directory manually"
 	pr_stdout " "
     fi
     if ! rm -f "${WORKDIR_BASE}${SCRIPTNAME}".lock 2>/dev/null; then
 	pr_stdout " "
-	pr_stdout " WARNING: Deletion of ${WORKDIR_BASE}${SCRIPTNAME} failed"
-	pr_stdout " Please remove the file manually"
+	pr_stdout "WARNING: Deletion of ${WORKDIR_BASE}${SCRIPTNAME} failed"
+	pr_stdout "Please remove the file manually"
 	pr_stdout " "
     fi
 }
@@ -779,12 +788,13 @@ environment_cleanup()
 emergency_exit()
 {
     pr_stdout " "
-    pr_stdout " INFO: Data collection has been interrupted"
-    pr_stdout " INFO: Cleanup of temporary collected data"
+    pr_stdout "INFO: Data collection has been interrupted"
+    pr_stdout "INFO: Cleanup of temporary collected data"
     environment_cleanup
-    pr_stdout " INFO: Emergency exit processed"
-    
+    pr_stdout "INFO: Emergency exit processed"
+
     pr_stdout " "
+    logger -t "${SCRIPTNAME}" "Data collection interrupted"
     exit;
 }
 
@@ -806,10 +816,27 @@ pr_log_stdout()
 }
 
 
+########################################
+# Function to print to stdout and into log file when rediretion is active
+pr_syslog_stdout()
+{
+    echo "$@"
+    echo "$@" >&8
+    logger -t ${SCRIPTNAME} "$@"
+}
+
+
 ###############################################################################
 # Running the script
 
 commandline_parse ${*}
+
+# Verification to run as root
+if test `/usr/bin/id -u 2>/dev/null` -ne 0; then
+    echo "ERROR: You must be user root to run ${SCRIPTNAME}!"
+    exit 1
+fi
+
 environment_setup
 print_version
 
@@ -820,11 +847,13 @@ exec 8>&1 9>&2 >${LOGFILE} 2>&1
 trap emergency_exit 1 2 15
 
 pr_log_stdout ""
-pr_log_stdout " Hardware platform     = `uname -i`"
-pr_log_stdout " Kernel version        = ${KERNEL_VERSION}.${KERNEL_MAJOR_REVISION}.${KERNEL_MINOR_REVISION} (`uname -r 2>/dev/null`)"
-pr_log_stdout " Runtime environment   = `test ${LINUX_ON_ZVM} -eq 0 && echo 'z/VM' || echo 'LPAR'`"
+pr_log_stdout "Hardware platform     = `uname -i`"
+pr_log_stdout "Kernel version        = ${KERNEL_VERSION}.${KERNEL_MAJOR_REVISION}.${KERNEL_MINOR_REVISION} (`uname -r 2>/dev/null`)"
+pr_log_stdout "Runtime environment   = ${RUNTIME_ENVIRONMENT}"
 pr_log_stdout ""
 
+logger -t "${SCRIPTNAME}" "Starting data collection"
+
 collect_cmdsout
 
 collect_vmcmdsout
@@ -845,6 +874,8 @@ create_package
 
 environment_cleanup
 
+logger -t "${SCRIPTNAME}" "Data collection completed"
+
 exec 1>&8 2>&9 8>&- 9>&-
 
 #EOF
diff --git a/scripts/dbginfo.sh.1 b/scripts/dbginfo.sh.1
index cdef849..c0975cc 100644
--- a/scripts/dbginfo.sh.1
+++ b/scripts/dbginfo.sh.1
@@ -1,5 +1,5 @@
-.TH DBGINFO.SH  1 "November 2012" "s390-tools"
- 
+.TH DBGINFO.SH  1 "October 2013" "s390-tools"
+
 .SH NAME
 dbginfo.sh \- collect runtime, configuration and trace information
 for debugging Linux on System z
@@ -44,35 +44,35 @@ Sample invocation:
 .P
 [root@host]# dbginfo.sh
 .br
- dbginfo.sh: Debug information script version %S390_TOOLS_VERSION%
+dbginfo.sh: Debug information script version %S390_TOOLS_VERSION%
 .br
- Copyright IBM Corp. 2002, 2012
+Copyright IBM Corp. 2002, 2013
 .PP
- Hardware platform     = s390x
+Hardware platform     = s390x
 .br
- Kernel version        = 3.0.13 (3.0.13\-0.27\-default)
+Kernel version        = <kernel\-version>
 .br
- Runtime environment   = z/VM
+Runtime environment   = z/VM
 .PP
- 1 of 7: Collecting command output
+1 of 7: Collecting command output
 .PP
- 2 of 7: Collecting z/VM command output
+2 of 7: Collecting z/VM command output
 .PP
- 3 of 7: Collecting procfs
+3 of 7: Collecting procfs
 .PP
- 4 of 7: Collecting sysfs
+4 of 7: Collecting sysfs
 .PP
- 5 of 7: Collecting log files
+5 of 7: Collecting log files
 .PP
- 6 of 7: Collecting config files
+6 of 7: Collecting config files
 .PP
- 7 of 7: Collecting osa oat output skipped
+7 of 7: Collecting osa oat output skipped \- not available
 .PP
- Finalizing: Creating archive with collected data
+Finalizing: Creating archive with collected data
 .PP
- Collected data was saved to:
+Collected data was saved to:
 .br
- >>  /tmp/DBGINFO\-2012\-10\-14\-13\-10\-42-host-123456.tgz  <<
+ >>  /tmp/DBGINFO\-2013\-10\-08\-10\-43\-16\-host\-012345.tgz  <<
 .SH HINTS
 Run the script with root authority.
 .br
-- 
1.8.5.3


From 31cd858e82efd289c4ea8ea4801346746aefcd2c Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Dan=20Hor=C3=A1k?= <dan@danny.cz>
Date: Tue, 19 Nov 2013 18:02:35 +0100
Subject: [PATCH 07/12] dbginfo.sh: avoid double data collection

Description:  dbginfo.sh: avoid double data collection
Symptom:      Execution of dbginfo.sh fails with 'no space left on device'
Problem:      The data collection of the dbginfo.sh script collects two times
              entries from the sysfs. First, the script itself collects
              all 'files' and later on, the script ziomon_fcpconf is
              collecting a subset of the sysfs along with some additional
              data. The additional data (information about the /dev entries)
              is collected by the dbginfo.sh script also. Therefore, the
              execution of ziomon_fcpconf is obsolete.
Solution:     Avoid the execution of ziomon_fcpconf in the dbginfo.sh script
Reproduction: Run the dbginfo.sh script on a machine, where /tmp should be
              able to cover the amount of data being collected. The machine
              should have quite a lot of devices being attached.
---
 scripts/dbginfo.sh | 4 ----
 1 file changed, 4 deletions(-)

diff --git a/scripts/dbginfo.sh b/scripts/dbginfo.sh
index 9b64076..e83774b 100755
--- a/scripts/dbginfo.sh
+++ b/scripts/dbginfo.sh
@@ -81,9 +81,6 @@ readonly OUTPUT_FILE_VMCMD="${WORKPATH}zvm_runtime.out"
 # File that includes content of files from sysfs
 readonly OUTPUT_FILE_SYSFS="${WORKPATH}sysfsfiles.out"
 
-# File that includes content of zFCP settings
-readonly OUTPUT_FILE_FCPCONF="${WORKPATH}scsi"
-
 # File that includes content of OSA OAT
 readonly OUTPUT_FILE_OSAOAT="${WORKPATH}osa_oat"
 
@@ -314,7 +311,6 @@ CMDS="uname -a\
   :java -version\
   :cat /root/.bash_history\
   :env\
-  :ziomon_fcpconf -o ${OUTPUT_FILE_FCPCONF}\
   "
 
 ########################################
-- 
1.8.5.3


From 4009f4a16c96f7fee65d77de112ef61109fdc0bb Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Dan=20Hor=C3=A1k?= <dan@danny.cz>
Date: Wed, 15 Jan 2014 15:08:29 +0100
Subject: [PATCH 08/12] zipl: fix segmentation fault in automenu array

Description:  zipl: fix segmentation fault in automenu array
Symptom:      Building an automenu with a large number of entries may
              lead to a 'double free or corruption' error in zipl.
Problem:      The array to store automenu items is to small.
Solution:     Correct the calculation for automenu array size.
Reproduction: Use zipl and build an automenu with a large number of
              entries in the zipl configuration file.
---
 zipl/src/scan.c | 12 ++++++++----
 1 file changed, 8 insertions(+), 4 deletions(-)

diff --git a/zipl/src/scan.c b/zipl/src/scan.c
index 597b01c..c357418 100644
--- a/zipl/src/scan.c
+++ b/zipl/src/scan.c
@@ -1672,10 +1672,14 @@ scan_build_automenu(struct scan_token* scan)
 		if (scan[i].id == scan_id_section_heading)
 			num_sections++;
 	}
-	size = /* old scan array + delimiter */ i + 1 +
-	       /* defaultboot heading + keyword */ 2 +
-	       /* automenu heading + keywords */ 10 +
-	       /* missing target definitions */ num_sections * num_targets;
+	size = /* old scan array + delimiter */     i + 1 +
+	       /* defaultboot heading  */           1 +
+	       /* defaultmenu */                    1 +
+	       /* menu heading  */                  1 +
+	       /* keyword default,prompt,timeout */ 3 +
+	       /* target keywords*/                 num_targets +
+	       /* missing target definitions */     num_sections * num_targets +
+	       /* number assigment  */              num_sections;
 	size *= sizeof(struct scan_token);
 	new_scan = misc_malloc(size);
 	if (!new_scan)
-- 
1.8.5.3


From 5eca8bced9faf6a15bdb7a0c43b53b6817a53473 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Dan=20Hor=C3=A1k?= <dan@danny.cz>
Date: Wed, 29 Jan 2014 10:37:03 +0100
Subject: [PATCH 09/12] zipl: Fix zfcpdump "struct job_ipl_data" initialization

Description:  zipl: Fix zfcpdump "struct job_ipl_data" initialization
Symptom:      When zfcpdump starts, dump fails and the following error
              message is written:
              ERROR: open() source device '/sys/kernel/debug/zcore/mem' failed!
Problem:      Because the "struct job_ipl_data" stack variable is not
              initialized in add_dump_program() the "is_kdump" member can
              be non-zero in case of zfcpdump. This makes the zfcpdump
              code think that stand-alone kdump is triggered instead of
              zfcpdump and then "zcore/mem" is not created by the kernel.
Solution:     Initialize "struct job_ipl_data" with zeroes.
Reproduction: 1) Prepare SCSI disk with zipl:
                 # mount /dev/sda1 /mnt
                 # zipl -D /dev/sda1 -t /mnt
              2) Trigger SCSI dump

              Note: Because the problem occurs only if the stack variable is
              not zero the problem will not occur every time.
---
 zipl/src/bootmap.c | 1 +
 1 file changed, 1 insertion(+)

diff --git a/zipl/src/bootmap.c b/zipl/src/bootmap.c
index 68dffe1..d573eda 100644
--- a/zipl/src/bootmap.c
+++ b/zipl/src/bootmap.c
@@ -661,6 +661,7 @@ add_dump_fs_program(int fd, struct job_dump_fs_data* dump_fs,
 	int rc;
 
 	/* Convert fs dump job to IPL job */
+	memset(&ipl, 0, sizeof(ipl));
 	ipl.image = dump_fs->image;
 	ipl.image_addr = dump_fs->image_addr;
 	ipl.ramdisk = dump_fs->ramdisk;
-- 
1.8.5.3


From 89e147e16348335cdfe6438e43171e7848e94dce Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Dan=20Hor=C3=A1k?= <dan@danny.cz>
Date: Mon, 3 Feb 2014 09:55:38 +0100
Subject: [PATCH 10/12] znetconf,lsqeth: Allow for 16-char network interface
 name

Description:  znetconf,lsqeth: Allow for 16-char network interface names
Symptom:      In the output of `znetconf -c` interface name is truncated.
              In the output of `lsqeth -p` interface name is jammed with the
              following field (card type). This happens when the "new"
              interface names are in play, i.e. "enccw0.0.e000" rather than
              traditional "eth1".
Problem:      In the functions that are doing formatted printout, the width
              of the field reserved for the interface name is insufficinet.
Solution:     Printing procedures in the `zneconf` and `lsqeth` are modified
              to allow the interface names of up to 16 characters (IFNAMSIZ).
Reproduction: Rename some network interface to use more characters than
              the usual 4. E.g. if the original interace name is "eth1",
              use this command:
                  ip link set dev eth1 name 123456789ABCDEF
              (Note: while the maximum length of the interface name is 16
              chars, the `ip` command limits it to 15 chars.) Issue the
              commands `znetconf -c` and `lsqeth -p`. Observe that the
              interface name is truncated in the `znetconf` output, and
              jammed together with the "card type" field in the `lsqeth`
              output.
---
 zconf/lsqeth   | 6 +++---
 zconf/znetconf | 2 +-
 2 files changed, 4 insertions(+), 4 deletions(-)

diff --git a/zconf/lsqeth b/zconf/lsqeth
index c3a0c64..bcd6277 100755
--- a/zconf/lsqeth
+++ b/zconf/lsqeth
@@ -238,7 +238,7 @@ function __print_proc_format
 
 	# print device data
 	printf '%-27s' "${format_array_print[0]}/${format_array_print[1]}/${format_array_print[2]}"
-	for j in 6 11 15 5 7 11 5 5 6 5
+	for j in 6 17 15 5 7 11 5 5 6 5
 		do
 			if [ "$countc" -eq 3 ]; then
 				printf "%-${j}s" "x${format_array_print[$countc]}"
@@ -396,8 +396,8 @@ fi
 device_list_temp="`ls $interface_dir`"
 
 if [ $format = 1 ]; then
-	echo "devices                    CHPID interface  cardtype       port chksum prio-q'ing rtr4 rtr6 lay'2 cnt"
-	echo "-------------------------- ----- ---------- -------------- ---- ------ ---------- ---- ---- ----- -----"
+	echo "devices                    CHPID interface        cardtype       port chksum prio-q'ing rtr4 rtr6 lay'2 cnt"
+	echo "-------------------------- ----- ---------------- -------------- ---- ------ ---------- ---- ---- ----- -----"
 fi
 #
 # list entries for device
diff --git a/zconf/znetconf b/zconf/znetconf
index 73bbe32..87c881b 100755
--- a/zconf/znetconf
+++ b/zconf/znetconf
@@ -737,7 +737,7 @@ function list_configured()
 		supress_header=$1
 	fi
 
-	local LIST_FORMAT_STRING="%-26.26s %-7.7s %-14.14s %5.5s %-4.4s %-11.11s %-7.7s\n"
+	local LIST_FORMAT_STRING="%-26.26s %-7.7s %-14.14s %5.5s %-4.4s %-16.16s %-7.7s\n"
 	if [ $supress_header -eq 0 ]
 	then
 		printf "$LIST_FORMAT_STRING" "Device IDs" "Type" \
-- 
1.8.5.3


From 78560f75fa2ce043ff63647cc1618f69251dbbf7 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Dan=20Hor=C3=A1k?= <dan@danny.cz>
Date: Mon, 10 Feb 2014 10:20:51 +0100
Subject: [PATCH 11/12] znetconf: Allow for 16-char network interface names

Description:  znetconf: Allow for 16-char network interface names
Symptom:      In the output of `znetconf -r/R` interface name is truncated.
              This happens when the "new" interface names are in play,
              i.e. "enccw0.0.e000" rather than traditional "eth1".
Problem:      In the function that extracts the interface name from the
              "$CFGLINE" string, only 11 characters of the interface name
              are extracted.
Solution:     Modify the function to extract 16 chacaters of the interface
              name.
Reproduction: Rename some network interface to use more characters than
              the usual 4. E.g. if the original interace name is "eth1",
              use this command:
                  ip link set dev eth1 name 123456789ABCDEF
              (Note: while the maximum length of the intrface name is 16
              chars, the `ip` command limits it to 15 chars.)
              Issue command `znetconf -r <interface-name>`. Observe that
              interface name is truncated in the output.
---
 zconf/znetconf | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/zconf/znetconf b/zconf/znetconf
index 87c881b..09f0904 100755
--- a/zconf/znetconf
+++ b/zconf/znetconf
@@ -1092,7 +1092,7 @@ function ask_for_remove()
 function extract_interface_name()
 {
 	local CFGLINE="$1"
-	local IF_NAME=$(expr substr "$CFGLINE" 62 11)
+	local IF_NAME=$(expr substr "$CFGLINE" 62 16)
 	REPLY=${IF_NAME%% *}
 	return 0
 }
-- 
1.8.5.3


From 883724cff09a02a19268a47102816e161a4b01af Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Dan=20Hor=C3=A1k?= <dan@danny.cz>
Date: Mon, 10 Feb 2014 10:21:23 +0100
Subject: [PATCH 12/12] qetharp: Allow for 16-char network interface names

Description:  qetharp: Allow for 16-char network interface names
Symptom:      In the output of `qetharp -p` interface name is truncated.
              This happens when the "new" interface names are in play,
              i.e. "enccw0.0.e000" rather than traditional "eth1".
Problem:      In the functions that are doing formatted printout, the width
              of the field reserved for the interface name is insufficinet.
Solution:     Printing procedure is modified to allow the interface names
              of up to 16 characters (IFNAMSIZ).
Reproduction: Rename some network interface to use more characters than
              the usual 4. E.g. if the original interace name is "eth1",
              use this command:
                  ip link set dev eth1 name 123456789ABCDEF
              (Note: while the maximum length of the intrface name is 16
              chars, the `ip` command limits it to 15 chars.)
              Issue command `qetharp -p <interface-name>`. Observe that
              interface name is truncated in the output.
---
 qetharp/qetharp.c | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/qetharp/qetharp.c b/qetharp/qetharp.c
index 58debdc..5eccda3 100644
--- a/qetharp/qetharp.c
+++ b/qetharp/qetharp.c
@@ -79,7 +79,7 @@ qeth_hex_dump(unsigned char *buf, int len)
 static void
 show_header() 
 {
-	printf("%-40.40s%-20.20s%-10.10s%-10.10s\n", 
+	printf("%-40.40s%-20.20s%-10.10s%-16.16s\n",
 	       "Address","HWaddress","HWType","Iface");
 }
 
@@ -152,7 +152,7 @@ void show_entry5(__u8 ipaddr_type, __u8 *ip, struct option_info *opin)
 				name = fqhn;
 			}
 		}
-		printf("%-40.40s%-20.20s%-10.10s%-10.10s\n", name, "","hiper",
+		printf("%-40.40s%-20.20s%-10.10s%-16.16s\n", name, "","hiper",
 			opin->dev_name);
 	}
 
@@ -219,7 +219,7 @@ void show_entry7(__u8 ipaddr_type, __u8 *ip, __u8 *mac,
 		sprintf(macstrbuf,"%02x:%02x:%02x:%02x:%02x:%02x",
 			mac[0],mac[1],mac[2],mac[3],mac[4],mac[5]);
 
-		printf("%-40.40s%-20.20s%-10.10s%-10.10s\n", name, macstrbuf,
+		printf("%-40.40s%-20.20s%-10.10s%-16.16s\n", name, macstrbuf,
 			(flags==OSACARD_FLAGS)? "ether":
 			(flags==OSA_TR_FLAGS)? "tr":"n/a",
 			opin->dev_name);
-- 
1.8.5.3

